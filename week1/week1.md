# **Week 1 (7.12 ~ 7.18)**

## **4장 변수**

- **식별자** (38p)
  - 어떤 값을 구별해서 식별할 수 있는 고유한 이름
  - 변수 이름이 이에 해당된다
  - 식별자는 값이 아닌 **메모리 주소를 기억**하고있다
- **변수 호이스팅** (42p)
  - 변수 선언문이 코드의 선두로 끌어 올려진 것 처럼 동작하는 자바스크립트의 고유의 특징
  - 아래의 코드에서 참조 에러(ReferenceError)가 아닌 undefined가 나온다
  - 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점(런타임)이 아닌 그 이전 단계에서 먼저 실행되기 때문이다

```jsx
console.log(score); // undefined
let score; //  변수 선언문
```

- **가비지 컬렉터** (46p)
  - 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 말한다.
  - 더 이상 사용하지 않는 메모리 → 어떤 식별자도 참조하지 않는 메모리 공간
  - js는 가비지 컬렉터를 내장하고 있는 매니지드 언어로, 이를 통해 메모리 누수를 방지한다
  - **하지만 시점은 예측할 수 없다**
- **식별자 네이밍 규칙(예약어)** (47p)
  - 예약어 x (await, break 등 사용되고 있는 언어)
  - 특수문자 제외 문자, 숫자, 언더스코어(\_), 달러 기호($) 포함 가능
  - 숫자로 시작하는 것은 허용하지 않는다
  - 네이밍 컨벤션
    - 카멜 케이스 - firstName
    - 스네이크 케이스 -first_name
    - 파스칼 케이스 - FirstName
    - 헝가리언 케이스 - strFirstName, $elem, observable$

## 5장 표현식과 문

- **리터럴 (**51p)
  - 사람이 이해할 수 있는 문자 or 약속된 기호를 사용해 값을 생성하는 표기법
    - 100, true, false, null 등
- **표현식 (**52p)
  - 값으로 평가될 수 있는 문, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다
  - 위의 리터럴은 값으로 평가되므로 리터럴도 표현식이다
  - var score = 100; ⇒ 100은 리터럴, 값을 생성하므로 자체로도 표현식
  - var score = 50 + 50; ⇒ 리터럴과 연산자로 이뤄져있다, 숫자 100을 생성하므로 표현식
- **문 (**54p, 57p)
  - 프로그램을 구성하는 기본 단위이자 최소 실행 단위
  - 문은 여러 토큰으로 구성되며, 토큰은 문법적 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다
    - 키워드, 식별자, 연산자, 리터럴, 세미콜론 등…
  - **표현식은 문의 일부일 수도 있고 그 자체로 문이 될 수도 있다.**
    - 구분하는 법은 변수에 할당해보는 것, 표현식은 문의 값으로 평가되므로 변수에 할당이 가능
    - 하지만 표현식이 아닌 문은 값으로 평가가 안되므로 에러가 발생
      - var x; → 변수 선언문, 값으로 평가가 안되서 문
      - x = 1;0; → 할당문, 표현식이면서 완전한 문

## 6장 데이터 타입

- **원시타입, 객체타입** (59p)
  - 원시타입 : 숫자, 문자열, 불리언, undefined, null, 심볼
  - 객체타입 : 객체, 함수, 배열
- **템플릿 리터럴** (62p)
  - `` 백틱을 사용하여 표현
- **표현식 삽입** (64p)
  - - 연산자를 사용

      - 피연산자 중 하나 이상이 문자열인 경우, 문자열 연결 연산자로 동작

      ```jsx
      let first = "SeungHun";
      let last = "Byeon";

      console.log("My Name is" + first + last);
      ```
  - 표현식을 삽입하려면 ${ }로 표현식을 감싼다, 이때 문자열로 타입이 강제로 변환되어 삽입된다
    - 표현식 삽입은 반드시 템플릿 리터럴 내에서 사용해야 한다
    ```jsx
    let first = "SeungHun";
    let last = "Byeon";

    console.log(`My Name is ${first} ${last}`);

    console.log(`1+2 = ${1 + 2}`);
    ```
- **undefined, 선언과 정의** (66p)
  - 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 빈 상태로 내버려두지 않고 js엔진이 undefined로 초기화한다
  - 아래의 예시처럼 개발자가 의도한 것이 아닌 js엔진이 변수를 초기화 할 때 사용하는 값이다
  - ★만약 변수에 값이 없다는 것을 명시하려면 **null을 할당하자**
  ```jsx
  const foo;
  console.log(foo); // undefined
  ```
  - **선언과 정의 - 변수는 ‘선언’, 함수는 ‘정의’**
- **null (**67p)
  - 변수에 값이 없다는 것을 의도적으로 명시할 때 사용한다
  - null을 할당하는 것은 변수가 이전에 참조한 값을 더 이상 참조를 하지 않겠다는 의미이며, 이는 곧 이전에 할당되었던 값에 대한 참조를 명시적으로 제거한다는 뜻이다
    - js엔진은 이 대상에 대해 가비지 콜렉션을 수행할 것이다
  - 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다
- **데이터타입이 필요한 이유, 동적 타이핑** (70p)
  - **데이터 타입이 필요한 이유**
    - 값을 저장할 때 확보해야 하는 **메모리 공간의 크기**를 결정하기 위해
    - 값을 참조할 때 한 번에 읽어 들여야 할 **메모리 공간의 크기**를 결정하기 위해
    - 메모리에서 읽어 들인 **2진수를 어떻게 해석**할지 결정하기 위해
  - **동적 타이핑**
    - typeof 연산자를 통해 데이터 타입을 확인
      - {}, [] 은 둘 다 object로 나온다
    - js의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)이 된다
    - 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다

## 7장 연산자

- **쉼표 연산자** (87p)
  - , : 왼쪽 피연산자 부터 차례대로 피연산자를 평가, 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환
  ```jsx
  let x, y, z;
  (x = 1), (y = 2), (z = 3); // 3
  ```
- **typeof null** (88p)
  - typeof null ⇒ object를 반환한다.
  - null을 확인하려면 === 연산자를 사용하자
  - 선언하지 않은 식별자를 typeof로 연산해보면 ReferenceError가 아닌 undefined를 반환한다
- **지수연산자** (89p)
  - \*\* : 제곱
  - Math.pow(밑, 지수)
  - 음수를 거듭 제곱의 밑으로 사용해 계산하려면 괄호로 묶어야 한다
  - 지수 연산자는 이항 연산자 중에서 우선순위가 가장 높다
  ```jsx
  -5 ** 2; // error
  (-5) ** 2; // 25

  2 * 5 * 2; // 50
  ```

## 8장 제어문

- **switch문** (97p)
  ```jsx
  switch (표현식) {
  	case 표현식1:
  		표현식 === 표현식1
  		break;
  		...
  	default:
  		표현식 !== 모든 case의 표현식;
  }
  ```
- **while문 (**103p)

```jsx
while (조건식) {
	조건에 맞을 때 까지 반복
}
// -----------------------------//
do {
	조건에 맞을 떄 까지 반복
} while (조건식)
```

## 9장 타입 변환과 단축 평가

- **암묵적 타입 변환** (110p)
  - **문자열**
    - 타입 뒤에 + ‘’
    - 0 + ‘’ ⇒ ‘0’, true+’’ ⇒ ‘true’
  - **숫자열**
    - 타입 앞에 +
    - ex) +’’ ⇒ 0, +’1’ ⇒ 1, +true ⇒ 1, +false → 0
  - **불리언**
    - Falsy값
      - false
      - undefined
      - null
      - 0, -0
      - NaN
      - ‘’
- **명시적 타입 변환** (115p)
  - **문자열**
    - String()
  - **숫자열**
    - Number()
  - **불리언**
    - Boolean()
- **단축평가 (**118p)
  - **논리 연산자를 사용한 단축 평가** (119p)
    - A && B ⇒ B : 두 개 모두가 true일때 true를 반환, 두 번째 피연산자를 반환
    - A || B ⇒ A : 두 개중 하나만 true여도 true를 반환, 첫 번째가 true면 첫 번째를 반환
  | true && anything  | anything |
  | ----------------- | -------- | -------- | -------- |
  | false && anything | false    |
  | true              |          | anything | true     |
  | false             |          | anything | anything |
  - **옵셔널 체이닝 연산자** (122p)
    - ?.
    - 좌항이 null이나 undefined인 경우 undefined를 반환, 아니라면 우항의 프로퍼티 참조를 이어간다
    ```jsx
    let elem = null;
    let value = elem?.value;
    console.log(value); // undefined
    ```
  - **null 병합 연산자** (123p)
    - ??
    - 좌항이 null이나 undefined인 경우 우항을 반환, 아니라면 좌항을 반환
    ```jsx
    let foo = null ?? "default string";
    console.log(foo); // "default string"
    ```

## 10장 객체 리터럴

- **객체의 개념** (124p)
  - js는 객체 기반의 프로그램언어이며, js를 구성하는 거의 모든 것이 객체다
  - 원시 값을 제외한 나머지 값(함수, 배열, 정규표현식 등)은 모두 객체다.
  - **원시 값은 변경이 불가능한 값**이지만 객체 타입의 값, 즉 **객체는 변경 가능한 값**이다
- **프로퍼티와 메서드 정의** (125p)
  - 프로퍼티 : 객체의 상태를 나타내는 값(data)
  - 메서드 : 프로퍼티를 참조하고 조작할 수 있는 동작
  ```jsx
  const counter = {
    num: 0, // 프로퍼티
    increase: function () {
      // 메서드
      this.num++;
    },
  };
  ```
- **인스턴스 정의** (125p)
  - 클래스에 의해 생성되어 메모리에 저장된 실체
  - 객체지향 프로그래밍에서 객체는 클래스와 인스턴스를 포함한 개념이다
  - 클래스는 인스턴스를 생성하기 위한 템플릿의 역할을 한다
- **프로퍼티 값 선언 방법** (128p)
  - 프로퍼티 키를 동적으로 생성하는 방법은 프로퍼티 키로 사용할 표현식을 대괄호로 묶어야 한다
  ```jsx
  let obj = {};
  let key = "hello";

  obj[key] = "world";

  console.log(obj); // {hello: "world"}
  ```

## 11장 원시 값과 객체의 비교

- **원시 타입 (137p~)**
  - **원시 타입** : 숫자, 문자열, 불리언, undefined, null, 심볼
  - 변경이 불가능한 값, **변수가 아닌 원시 값에 대한 진술**
  ```jsx
  const o = {}; // const는 재할당이 불가능,  const로 선언한 변수에 할당한 원시 값은 변경 불가
  o.a = 1; // 하지만 객체는 객체타입 이므로 변경 가능
  console.log(o); // {a: 1}
  ```
  - 변수에 값을 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장
  - 원시 값을 갖는 변수를 다른 변수에 할당하면 **원시 값이 복사되어 전달 → 값에 의한 전달**
  - 원시 타입의 경우는 변수에 값을 재 할당 시 메모리 주소가 바뀐다 → **불변성**
  - 유사 배열 객체 : 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체
    - 문자열은 마치 배열처럼 인덱스를 통해 접근이 가능
    - length 프로퍼티를 갖기 때문에 for문으로 순회 가능
    ```jsx
    let str = string;
    console.log(str[0]); // s
    console.log(str.length); // 6
    ```
  - **값에 의한 전달**
    - 변수에 원시 값을 갖는 변수를 할당하면 할당 받는 변수(copy)에는 할당되는 변수(score)의 원시 값이 복사 되어 전달된다
    - 변수에 값이 전달되는 것이 아닌 메모리 주소가 전달 되는 것
    - 변수와 같은 식별자는 값이 아닌 메모리 주소를 기억하고 있기 때문이다
    - 결국 두 변수의 원시 값은 서로 다른 메모리 공간에 저장되어있어 재할당을 통해 값을 변경하더라도 서로 간섭이 불가능하다
    ```jsx
    let score = 80;
    let copy = 80;

    console.log(score, copy); // 80, 80

    score = 100;

    console.log(score, copy); // 100, 80
    ```
- **객체 타입 (137p, 146p~)**
  - **객체 타입** : 객체, 함수, 배열
  - 변경이 가능한 값
  - 변수에 값을 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장, 주소를 통해 참조 값에 접근 가능
  - 재할당 없이 객체를 직접 변경 가능→ 동적으로 프로퍼티를 추가, 수정, 삭제가 가능
  - **얕은 복사 (150p)**
    - 한 단계 까지만 복사
    - 원본과는 다른 객체, 원본과 복사본은 참조 값이 다른 별개의 객체
    - 객체에 중첩되어 있는 객체의 경우 참조 값을 복사
  - **깊은 복사**
    - 객체에 중첩되어 있는 객체까지 모두 복사
    - 원본과는 다른 객체, 원본과 복사본은 참조 값이 다른 별개의 객체
    - 객체에 중첩되어 있는 객체까지 모두 복사해서 원시 값 처럼 완전한 복사본을 만든다
    ```jsx
    const o_o = { x: { y: 1 } };

    // 얕은 복사
    const c1 = { ...o_o };
    console.log(c1 === o_o); // false
    console.log(c1.x === o_o.x); // true

    // lodash 의 cloneDeep을 이용한 깊은 복사
    const _ = require("lodash");
    // 깊은복사
    const c2 = _.cloneDeep(o_o);
    console.log(c2 === o_o); // false
    console.log(c2.x === o_o.x); // false

    const v = 1;

    // 깊은 복사
    const c1 = v;
    console.log(c1 === v); // true

    const o = { x: 1 };
    // 얕은 복사
    const c2 = o;
    console.log(c2 === o); // true
    ```
  - **참조에 의한 전달 (151p)**
    - 객체를 가리키는 변수(원본, preson)를 다른 변수(사본, copy)에 할당하면 **원본의 참조 값이 복사되어 전달**
    - 두 개의 식별자가 하나의 객체를 공유
    - **값에 의한 전달**, **참조에 의한 전달** 모두 식별자가 기억하는 **메모리 공간에 저장되어 있는 값을 복사해서 전달**하는 면에서 동일
    - js에는 **참조에 의한 전달은 존재하지 않고 값에 의한 전달만 존재**한다
  ```jsx
  let person = { name: "Byen" };

  // 참조 값을 복사, 얕은 복사
  let copy = person;

  console.log(person === copy); // true

  copy.name = "Kim";
  person.address = "Ilsan";

  console.log(person); // {name:'Kim', address:'Ilsan'}
  console.log(copy); // {name:'Kim', address:'Ilsan'}

  let person1 = { name: "Lee" };
  let person2 = { name: "Lee" };

  console.log(person1 === person2); // false
  console.log(person1.name === person2.name); // true
  ```

## 12장 함수

- **함수의 정의 (155p)**
  - 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 저장한 것
  ```jsx
  function add(x, y) => {
  	return x+y;
  }
  add(1,2); // 3

  /*
  add : 함수 이름
  (x,y): x,y는 매개 변수
  return x+y: 반환 값
  add(1,2) : 함수 호출 / 1,2는 인수
  const ~ {} : 함수 몸체
  */
  ```
  - 함수 사용 이유 : 코드 재 사용이 유용해서
  - **함수 선언문 (159p)**
    - function add(x, y) { …
    - 함수 이름 생략 불가능
    - 표현식이 아닌 **문**
    - 함수 객체를 가리키는 식별자로 호출한다 ex) add(1, 2)
  - **함수 표현식 (163p)**
    - let add = function (x, y) { …
    - 값의 성질을 갖는 일급 객체
  - **함수 생성 시점과 함수 호이스팅 (164p)**
    ```jsx
    // 함수 참조
    console.log(dir(add)); // f add(x,y)
    console.log(dir(sub)); // undefined
    // 함수 호출
    console.log(add(2, 5)); // 7
    console.log(sub(2, 5)); // TypeError: sub is not a function
    // 함수 선언문
    function add(x, y) {
      return x + y;
    }

    // 함수 표현식
    let sub = function (x, y) {
      return x - y;
    };
    ```
    - 함수 선언문과 함수 표현식으로 생성한 함수들은 생성 시점이 다르다
    - **호이스팅 : 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 js의 고유의 특징**
      - 변수 호이스팅과 미묘한 차이가 있다
      - 변수는 undefined로 초기화, 함수 선언문은 함수 객체로 초기화
      - 변수 할당문의 값은 런타임에 평가되므로, 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에서 평가되어 함수 객체가 된다
      - **함수 표현식으로 함수를 정의하면 함수 호이스팅이 아닌 변수 호이스팅이 발생**
  - **Function 생성자 함수 (166p)**
    - new 연산자와 함께 호출
    - new 없이 호출해도 결과는 동일
    ```jsx
    let add = new Function("x", "y", "return x + y");
    console.log(2, 5); // 7
    ```
  - **화살표 함수 (167p)**
    - ⇒ 를 사용해 더 간략한 방법으로 함수를 선언
    ```jsx
    const add = () => x + y;
    console.log(2, 5); // 7
    ```
  - **즉시 실행 함수(177p)**
    - 정의와 동시에 즉시 호출되는 함수
    - 단 한 번만 호출되며 재호출 불가
    - 익명 즉시 실행 함수를 사용하는 것이 일반적
    ```jsx
    // 익명 즉시 실행 함수
    (function () {
      let a = 3;
      let b = 5;
      return a * b;
    })();

    // 기명 즉시 실행 함수
    (function foo() {
      let a = 3;
      let b = 5;
      return a * b;
    })();
    ```
  - **재귀 함수 (179p)**
    - 함수가 자기 자신을 호출 하는 것
    ```jsx
    // ! : 팩토리얼 구현
    function factorial(n) {
      if (n <= 1) return 1;
      return n * factorial(n - 1);
    }
    ```
    - 탈출 조건이 필수, 없으면 무한 호출이 되어 스택 오버플로 에러가 발생한다
    - 대부분 for, while문으로 구현이 가능하다
  - **콜백 함수 (183p)**
    - 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
    - 매개변수를 통해 함수의 외부에서 콜백 함수를 전달 받은 함수를 고차 함수라 한다
    - 콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달 가능
    ```jsx
    // 익명 함수 리터럴을 콜백 함수로 고차 함수에 전달한다
    // 익명 함수 리터럴은 repeat 함수를 호출할 때마다 평가되어 함수 객체를 생성한다
    repeat(5, function (i) {
      if (i % 2) console.log(i);
    }); // 1 3

    // logOdds 함수는 단 한번만 생성
    var logOdds = function (i) {
      if (i % 2) console.log(i);
    };

    // 고차 함수에 함수 참조를 전달
    repeat(5, logOdds); // 1 3
    ```
  - **순수 함수와 비 순수 함수**
    - 외부 상태 : 전역 변수, 서버 데이터, 파일, Console, DOM 등
    - 순수 함수 : 어떤 외부 상태에 의존하지 않고 변경하지도 않는(부수 효과가 없는)함수
      - 최소 하나 이상의 인수를 전달 받음
      - 인수의 불변성을 유지(인수 변경x)
      ```jsx
      let count = 0;

      // 순수 함수 increase는 동일한 인수 전달 시, 언제나 동일 값을 반환
      function increase(n) {
        return ++n;
      }

      // 순수 함수가 반환한 결과값을 변수에 재할당하여 상태 변경
      count = increase(count);
      console.log(count); // 1

      count = increase(count);
      console.log(count); // 2
      ```
    - 비 순수 함수 : 외부 상태에 의존하거나 외부 상태를 변경하는(부수 효과가 있는)함수
      - 함수의 외부 상태에 따라 반환 값이 달라짐
      - 함수의 외부 상태를 변경하는 부수 효과가 있다
    ```jsx
    let count = 0;

    // 비 순수 함수
    function increase() {
      return ++count; // 외부 상태에 의존하며 외부 상태를 변경
    }

    // 비 순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다
    increase();
    console.log(count); // 1

    increase();
    console.log(count); // 2
    ```
